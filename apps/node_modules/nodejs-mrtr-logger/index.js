const fs = require('fs');
const path = require('path');
const split = require('split');
const moment = require('moment');
const winston = require('winston');
const morgan = require('morgan');
const DailyRotateFile = require('nodejs-mrtr-winston-daily-rotate-file-transporter');
const CryptoUtils = require('nodejs-mrtr-crypto');
const cryptoUtils = new CryptoUtils();
const mrtrError = require('nodejs-mrtr-error');
const https = require('https');
const zlib = require('zlib');
const os = require('os');

let configs = {};
const appPath = process.cwd();
configs = require(path.join(appPath, '..', 'conf', 'logger.json'));

let monitorTransporter;
let legacyMonitorTransporter;
let debugTransporter;
let exceptionTransporter;
let legacyDebugTransporter;
let legacyExceptionTransporter;
let morganMonitorTransporter;
let morganDebugTransporter;
let morganExceptionTransporter;

let loggerMorganMonitor;
let loggerMorganDebug;
let loggerMonitor;
let legacyMonitor
let loggerDebug;
let legacyDebug;


const monitorLogLevels = {
    info: 0,
    warn: 1,
    debug: 2,
    error: 3,
    verbose: 4,
    silly: 5
};

const logLegacyMonitorTransportFormatter = (opts) => {
    return [
        opts.timestamp(),
        opts.message
    ].join('|');
};

const logLegacyDebugTransportFormatter = (opts) => {
    return [
        opts.timestamp(),
        opts.level.toUpperCase(),
        opts.message
    ].join('|');
};

const logMorganMonitorTransportFormatter = (opts) => {
    return [
        opts.timestamp(),
        opts.message
    ].join('|');
};

const logMorganDebugTransportFormatter = (opts) => {
    return [
        opts.timestamp(),
        opts.level.toUpperCase(),
        opts.message
    ].join('|');
};

const timestamp = () => {
    return moment().format('YYYY-MM-DD HH:mm:ss.SSS');
};

const createTransporter = (config_key, formatter) => {
    let transporter = null;
    if (Object.prototype.hasOwnProperty.call(configs, config_key)) {
        let conf = configs[config_key];
        let hostName = process.env.HOSTNAME ? process.env.HOSTNAME : '';
        let datePattern = "yyyyMMDD";
        let currentDate = moment(new Date()).format(datePattern);
        let filename = conf.filename.replace('${dockerId}', hostName);
        filename = filename.replace('${date}', currentDate);
        let logPath = path.dirname(path.normalize(__dirname + '/../../' + filename));
        fs.existsSync(logPath) || fs.mkdirSync(logPath);
        conf.name = conf.name || config_key;
        conf.timestamp = timestamp;
        conf.formatter = formatter;
        transporter = new DailyRotateFile(conf);
    }
    return transporter;
};

const captureResponseBodyMiddleWare = (app) => {
    const originalSend = app.response.send;
    app.response.send = function (body) {
        app.response._body = body;
        originalSend.call(this, body);
    };
}

const genTransactionIdMiddleWare = (req, res, next) => {
    req.token = req.headers['x-authorization']
    req.transaction_id = (req.headers['x-request-id'] || "").replace(/-/g, '').toUpperCase();
    res.locals.transaction_id = (req.headers['x-request-id'] || "").replace(/-/g, '').toUpperCase();
    next();
};

const getServerNameMiddleWare = (req, res, next) => {
    req.server_name = process.env.HOSTNAME || os.hostname();
    next();
};

const getTransactionAmountMiddleWare = (req, res, next) => {
    let body = {};
    if (typeof (req.body) === 'object'){
            body = req.body;
    }else if (typeof (req.body) === 'string'){
            body = JSON.parse(req.body);
    }

    req.txn_amount = body.packageCode || body.amount || '';
    next();
};

const objectCopy = (data) => (data) ? JSON.parse(JSON.stringify(data)) : {};

const parseJsonAllProperty = (data) => {
    for (let attr in data) {
        let val = null;
        try {
            val = JSON.parse(data[attr]);
        } catch (e) {
            val = null;
        }
        if (val != null && typeof val === "object") data[attr] = val;
        if (typeof data[attr] !== "string") parseJsonAllProperty(data[attr]);
    }
};

morgan.token('req_body', (req) => {
    let body = '';
    if (typeof (req.body) === 'object') {
        parseJsonAllProperty(req.body);

            body = JSON.stringify(req.body);
    } else {
        body = req.body;

    }
    return body;
});

const REQUEST_WAY = "1";
const RESPONSE_WAY = "4";
const RESPONSE_ERROR_WAY = "5";

morgan.token('log_id', (req, res) => (res.finished) ? (req.err != null) ? RESPONSE_ERROR_WAY : RESPONSE_WAY : REQUEST_WAY);
morgan.token('log_direction', (req, res) => (res.finished) ? (req.err != null) ? RESPONSE_ERROR_WAY : RESPONSE_WAY : REQUEST_WAY);
morgan.token('transaction_id', (req, res) => req.transaction_id);
morgan.token('server_name', (req, res) => req.server_name);
morgan.token('res_body', (req, res) => res._body);
morgan.token('x_request_id', (req, res) => (req.headers['x-request-id'] || "").replace(/-/g, '').toUpperCase());
// morgan.token('x_feature_session_id', (req, res) => (req.headers['x-feature-session-id'] || "").replace(/-/g, '').toUpperCase());
morgan.token('ip_address', (req, res, tokens) => req.headers['x-real-ip'] || req.headers['x-forwarded-for'] ||
    req.headers['cf-connecting-ip'] || tokens['remote-addr'](req, res));

morgan.token('functionName', (req, res) => req.functionName);

const morganEncryptRequestHeader = (tokens, req, res) => {
    req.encryptedUserNameLogin = cryptoUtils.encrypt(req.headers['user-name-login']);
    req.encryptedSimrNumber = cryptoUtils.encrypt(req.headers['sim-r-number']);
    req.encryptedCustomerMobileNumber = cryptoUtils.encrypt(req.headers['customer-mobile']);
    const authorization = req.token || req.headers['x-authorization'] || "";
    req.auth_token = (authorization.length > 20) ? authorization.slice(-20) : authorization; // sub string right 20 characters
};

const getLegacyMonitorMessage = function() {
    throw new Error("deplicate");
}

const extract = (tokens, req, res, isDebug) => {
    // "MRTR ,error.code, error.type, error.mrtrCode,
    const logger = res.locals.logger;
    let body_log = "";
    let diff_time = tokens['response-time'](req, res, 0);
    let message_step = "";
    let error = {};

    if (res.finished) {

        if(req.err != null) {
            message_step = RESPONSE_ERROR_WAY;
            const errRow = req.err.getError();
            if (errRow != null) {
                let errorType

                if(isDebug){
                    const body = tokens.res_body(req, res);
                    let bodyStr = JSON.stringify(encryptJsonData(body, logger.info.x_authorization));
                    if(configs.security.maxLengthLog4 && configs.security.maxLengthLog4 != '-'){
                        errorType = (bodyStr.length > configs.security.maxLengthLog4) ? (bodyStr.substr(0, configs.security.maxLengthLog4-1)).concat("...") : bodyStr
                    }else{
                        errorType = bodyStr
                    }
                }else{
                    if(configs.security.maxLengthLog5 && configs.security.maxLengthLog5 != '-'){
                        errorType = (errRow.errorType.length > configs.security.maxLengthLog5) ? (errRow.errorType.substr(0, configs.security.maxLengthLog5-1)).concat("...") : errRow.errorType
                    }else{
                        errorType = errRow.errorType
                    }
                }

                error = {
                    return_code: errRow.legacyErrorCode,
                    error_type: errorType,
                    error_code: errRow.mrtrErrorCode
                };
            } else {
                let errorType
                if(configs.security.maxLengthLog5 && configs.security.maxLengthLog5 != '-'){
                    errorType = (req.err.codeType.length > configs.security.maxLengthLog5) ? (req.err.codeType.substr(0, configs.security.maxLengthLog5-1)).concat("...") : req.err.codeType
                }else{
                    errorType = req.err.codeType
                }

                error = {
                    return_code: req.err.code,
                    error_type: errorType,
                    error_code: ""
                };
            }
        } else {
            message_step = 4;
            if(isDebug) {
                const body = tokens.res_body(req, res);
                let bodyStr = JSON.stringify(encryptJsonData(body, logger.info.x_authorization));
                if(configs.security.maxLengthLog4 && configs.security.maxLengthLog4 != '-'){
                    body_log = (bodyStr.length > configs.security.maxLengthLog4) ? (bodyStr.substr(0, configs.security.maxLengthLog4-1)).concat("...") : bodyStr
                }else{
                    body_log = bodyStr
                }

                error = {
                    return_code : tokens.functionName(req, res, tokens),
                    error_type : body_log,
                    error_code : ""
                }
                
            }
            else {
                error = {
                    return_code: "",
                    error_type: "",
                    error_code: ""  
                }
            }
        }
    } else {
        message_step = 1;
        if(isDebug) {
            const body = tokens.req_body(req, res);
            let bodyStr = JSON.stringify(encryptJsonData(body, logger.info.x_authorization));
            if(configs.security.maxLengthLog1 && configs.security.maxLengthLog1 != '-'){
                body_log = (bodyStr.length > configs.security.maxLengthLog1) ? (bodyStr.substr(0, configs.security.maxLengthLog1-1)).concat("...") : bodyStr
            }else{
                body_log = bodyStr
            }

            error = {
                return_code: "",
                error_type: body_log,
                error_code: ""
                  
            }
        }
        else {
            error = {
                return_code: "",
                error_type: "",
                error_code: ""  
            }
        }
    }

    const opt = {
        message_step: message_step,
        diff_time: diff_time,
        return_code: error.return_code || "",
        error_type: error.error_type || "",
        error_code: error.error_code || ""
    };

    return opt;
}

const morganMonitorFormat = (tokens, req, res) => {

    const logger = res.locals.logger;
    const opt = extract(tokens, req, res, false);

    return logger.formatting(opt);

};

const morganDebugFormat = (tokens, req, res) => {

    const logger = res.locals.logger;
    const opt = extract(tokens, req, res, true);

    return logger.formatting(opt);
};

const encryptJsonData = (data, loginTokenAuth, encryptFields, encryptPinFields, bigDataFields, deleteFields) => {

    let loginToken = loginTokenAuth || "abcdef";
    let encryptedData = objectCopy(((typeof data === "string") ? JSON.parse(data) : data));

    let encFields = [...(new Set([...((configs['security'] || {}).enc_fields || []), ...(encryptFields || [])]))];
    let pinFields = [...(new Set([...((configs['security'] || {}).pin_fields || []), ...(encryptPinFields || [])]))];
    let datFields = [...(new Set([...((configs['security'] || {}).big_fields || []), ...(bigDataFields || [])]))];
    let delFields = [...(new Set([...((configs['security'] || {}).del_fields || []), ...(deleteFields || [])]))];

    let encParentfields = ((configs['security'] || {}).enc_parentfield || []);
    let encArrayFields = ((configs['security'] || {}).enc_array_field || []);
    let parentDatFields = ((configs['security'] || {}).dat_array_field || []);

    try {
        //handle array object type by 'encParentfield' flag
        if (encParentfields && eval('encryptedData.' + encParentfields + '.length') > 0) {
            for (let i = 0; i < eval('encryptedData.' + encParentfields + '.length'); i++) {
                for (let j = 0; j < encFields.length; j++) {
                    let val = null;
                    try {
                        var encField = encFields[j]
                        encField = encField.replace(encParentfields + ".", "")
                        var cmd = 'encryptedData.' + encParentfields + '[' + i + '].' + encField
                        val = eval(cmd);
                    } catch (e) {}

                    if (val != null) {
                        const encryptedVal = cryptoUtils.encrypt(val)
                        var encField = encFields[j]
                        encField = encField.replace(encParentfields + ".", "")
                        var cmd = 'encryptedData.' + encParentfields + '[' + i + '].' + encField + '="' + encryptedVal.replace(/(["\\])/ig, "\\$1") + '"'
                        eval(cmd);
                    }
                }
            }
            //handle array value type by 'encArrayField' flag
        } else if (encArrayFields && typeof [].concat(eval('encryptedData.' + encArrayFields))[0] != 'undefined') {
            for (let i = 0; i < [].concat(eval('encryptedData.' + encArrayFields)).length; i++) {
                let val = null;
                try {
                    val = [].concat(eval('encryptedData.' + encArrayFields))[i]
                } catch (e) {}

                if (val != null) {
                    const encryptedVal = cryptoUtils.encrypt(val)
                    eval('encryptedData.' + encArrayFields)[i] = encryptedVal
                }
            }
        } else {
            //handle object type
            for (let i = 0; i < encFields.length; i++) {
                let val = null;
                try {
                    val = eval('encryptedData.' + encFields[i]);
                } catch (e) {}
                if (val != null) {
                    const encryptedVal = cryptoUtils.encrypt(val);
                    eval('encryptedData.' + encFields[i] + '="' + encryptedVal.replace(/(["\\])/ig, "\\$1") + '"');
                }
            }
        }
    } catch (e) {

    }

    try {        
        for (let a = 0; a < parentDatFields.length; a++) {
            let countParentDatFields = 0
            try{
                countParentDatFields = eval('encryptedData.' + parentDatFields[a] + '.length')
            }catch (e) {}
            if (parentDatFields[a] && countParentDatFields > 0) {
                for (let i = 0; i < eval('encryptedData.' + parentDatFields[a] + '.length'); i++) {
                    for (let j = 0; j < datFields.length; j++) {
                        let val = null;
                        try {
                            var encField = datFields[j]
                            encField = encField.replace(parentDatFields[a] + ".", "")
                            var cmd = 'encryptedData.' + parentDatFields[a] + '[' + i + '].' + encField
                            val = eval(cmd);
                        } catch (e) {}

                        if (val != null) {
                            var encField = datFields[j]
                            encField = encField.replace(parentDatFields[a] + ".", "")
                            var cmd = 'encryptedData.' + parentDatFields[a] + '[' + i + '].' + encField + '="Base64Length(' + val.length +')"'
                            eval(cmd);
                        }
                    }
                }
            }
        }
    } catch (e) {

    }

    for (let i = 0; i < encFields.length; i++) {
        let val = null;
        try {
            val = eval('encryptedData.' + encFields[i]);
        } catch (e) {}
        if (val != null) {
            const encryptedVal = cryptoUtils.encrypt(val);
            eval('encryptedData.' + encFields[i] + '="' + encryptedVal.replace(/(["\\])/ig, "\\$1") + '"');
        }
    }
    for (let i = 0; i < pinFields.length; i++) {
        let val = null;
        try {
            val = eval('encryptedData.' + pinFields[i]);
        } catch (e) {}
        if (val != null) {
            const encryptedVal = cryptoUtils.encryptPin(val, loginToken);
            eval('encryptedData.' + pinFields[i] + '="' + encryptedVal.replace(/(["\\])/ig, "\\$1") + '"');
        }
    }
    for (let i = 0; i < datFields.length; i++) {
        let val = null;
        let val2 = null;
        try {
            val = eval('encryptedData.' + datFields[i]);
        } catch (e) {}
        try {
            val2 = eval('encryptedData.options.body.' + datFields[i]);
        } catch (e) {}
        if (val != null) {
            eval('encryptedData.' + datFields[i] + '="Base64Length(' + val.length +')"');
        }
        if (val2 != null) {
            eval('encryptedData.options.body.' + datFields[i] + '="Base64Length(' + val2.length +')"');
        }
    }
    for (let i = 0; i < delFields.length; i++) {
        let val = null;
        try {
            val = eval('encryptedData.' + delFields[i]);
        } catch (e) {}
        if (val != null) {
            eval('delete encryptedData.' + delFields[i]);
        }
    }

    return encryptedData;
};
// steam mogan configuration
const streamMonitor = split().on('data', (message) => {
    loggerMorganMonitor.info(message);
});

const streamDebug = split().on('data', (message) => {
    loggerMorganDebug.debug(message);
});
// mogan configuration
let monitorRequest = morgan(morganMonitorFormat, {
    stream: streamMonitor,
    immediate: true
});
let monitorResponse = morgan(morganMonitorFormat, {
    stream: streamMonitor,
    immediate: false
});
let debugRequest = morgan(morganDebugFormat, {
    stream: streamDebug,
    immediate: true
});
let debugResponse = morgan(morganDebugFormat, {
    stream: streamDebug,
    immediate: false
});

const registerRequestPromiseWithSupportDeflate = (rp, logger) => {
    let time_response;
    let service_name = '';
    let function_name = '';

    const execError = error => {
        let jsonBody = JSON.stringify(error);
        let err = new mrtrError({
            code: error.errCode,
            module: service_name
        });
        let resp = error.response;
        let elapsedTime = moment().diff(time_response);
        if (resp != null) elapsedTime = resp.elapsedTime;

        logger.monitor.info(`3|${elapsedTime}|${service_name}|${error.code}|${err.type}|${err.mrtrCode}`);
        logger.debug.debug(`3|${elapsedTime}|${service_name}|${error.errCode}|${err.codeType}|${err.mrtrCode}`);
        logger.debug.error(`5|${elapsedTime}|${service_name}|${function_name}|${jsonBody}|`);
        throw error;
    };
    const intercept = options => {
        options.time = true;
        if (options.hostname == null && options.hostname == null) throw Error("Request URL hostname is not definedp in roperty option.");
        if (options.path == null) throw Error("Request URL endpoint path is not defined in property option.");
        service_name = options.serviceName || "UNKNOWN_LEGACY";
        function_name = options.functionName;
        let req_body = objectCopy(options.body || options.json);
        let req_body_log = req_body == null ? "" :
            JSON.stringify(encryptJsonData(req_body, options.encryptFields, options.encryptPinFields, options.bigDataFields, options.removeFields));

        logger.monitor.info(`2|0|${service_name}|${function_name}||`);
        logger.debug.debug(`2|0|${service_name}|${function_name}|${req_body_log}|`);

        return new Promise((resolve, reject) => {

            time_response = moment();

            let httpsRequest = https.request(options, function (res) {

                let chunks = [];

                res.on('data', function (chunk) {
                    chunks.push(chunk);
                });

                res.on('end', function () {

                    let deflateBuffer = Buffer.concat(chunks);

                    zlib.inflateRaw(deflateBuffer, function (error, inflate) {

                        if (error) {
                            execError(error);
                            reject(error);
                        }

                        let elapsedTime = moment().diff(time_response);
                        let res_body = JSON.parse(inflate.toString());
                        let res_body_log = res_body == null ? "" :

                            JSON.stringify(encryptJsonData(res_body, options.encryptFields, options.encryptPinFields, options.bigDataFields, options.removeFields));

                        logger.monitor.info(`3|${elapsedTime}|${service_name}|${function_name}||`);
                        logger.debug.debug(`3|${elapsedTime}|${service_name}|${function_name}|${res_body_log}|`);

                        res_body.statusCode = res.statusCode;
                        resolve(res_body);
                    })
                });
            });

            httpsRequest.write(JSON.stringify(options.json))

            httpsRequest.end();
        });
    };

    return rp.defaults(intercept);
};

const registerRequestPromise = function (rp) {
    let time_response;
    let service_name = '';
    let function_name = '';
    const loggerMonitor = this.monitor;
    const loggerDebug = this.debug;
    const authenToken = this.authenToken;
    const execError = error => {
        const jsonBody = JSON.stringify(error);
        const err = new mrtrError({
            code: error.code,
            module: service_name
        });
        const resp = error.response;
        let elapsedTime = moment().diff(time_response);
        if (resp != null) elapsedTime = resp.elapsedTime;

        loggerMonitor.info(`3|${elapsedTime}|${service_name}|${error.code}|${err.codeType}|${err.code}`);
        loggerDebug.error(`3|${elapsedTime}|${service_name}|${error.errCode}|${err.codeType}|${err.code}`);
        loggerDebug.error(`5|${elapsedTime}|${service_name}|${function_name}|${jsonBody}|`);
        throw error;
    };
    const intercept = options => {
        options.time = true;
        if (options.uri == null && options.url == null) throw Error("Request URL is not defined. Request to remote require url or uri property option.");
        if (options.uri == null) options.uri = options.url;
        service_name = options.serviceName || "UNKNOWN_LEGACY";
        function_name = options.functionName || options.uri.split('/').pop();
        let req_body = objectCopy(options.body || options.json);
        let req_body_log = req_body == null ? "" :
            JSON.stringify(encryptJsonData(req_body, authenToken, options.encryptFields, options.encryptPinFields, options.bigDataFields, options.removeFields));

        loggerMonitor.info(`2|0|${service_name}|${function_name}||`);
        loggerDebug.debug(`2|0|${service_name}|${function_name}|${req_body_log}|`);

        return new Promise((resolve, reject) => {
            time_response = moment();
            rp(options, (err, res, res_body) => {
                if (res != null) {
                    let elapsedTime = moment().diff(time_response);
                    if (res.elapsedTime != null) elapsedTime = res.elapsedTime;
                    let res_body_log = res_body == null ? "" :
                        JSON.stringify(encryptJsonData(res_body, authenToken, options.encryptFields, options.encryptPinFields, options.bigDataFields, options.removeFields));

                    loggerMonitor.info(`3|${elapsedTime}|${service_name}|${function_name}||`);
                    loggerDebug.debug(`3|${elapsedTime}|${service_name}|${function_name}|${res_body_log}|`);

                    res_body.statusCode = res.statusCode;
                    resolve(res_body);
                } else if (err != null) {
                    execError(err);
                    reject(err);
                }
            }).catch(function (err) {
                execError;
                reject(err)
            });
        });
    };

    return rp.defaults(intercept);
};

const registerSoapPromise = function (soap, options) {
    let time_response;
    let service_name = '';
    let function_name = '';
    const loggerMonitor = this.monitor;
    const loggerDebug = this.debug;
    const authenToken = this.authenToken;

    const execError = error => {
        let jsonBody = JSON.stringify(error);
        // let resp = error.response;
        let elapsedTime = moment().diff(time_response);
        // if (resp != null) elapsedTime = resp.elapsedTime;

        loggerMonitor.info(`3|${elapsedTime}|${service_name}|${function_name}||`);
        loggerDebug.debug(`3|${elapsedTime}|${service_name}|${function_name}|${jsonBody}|`);
        loggerDebug.error(`3|${elapsedTime}|${service_name}|${function_name}|${jsonBody}|`);
        loggerDebug.error(`5|${elapsedTime}|${service_name}|${function_name}|${jsonBody}|`);

    };

    options.time = true;
    if (options.uri == null && options.url == null) throw Error("Request URL is not defined. Request to remote require url or uri property option.");
    if (options.uri == null) options.uri = options.url;
    service_name = options.serviceName || "UNKNOWN_LEGACY";
    function_name = options.functionName || options.uri.split('/')[options.uri.split('/').length - 1];

    if (!options.requestArgs) throw Error("Request requestArgs is not defined. Request to remote require requestArgs property option.");

    let req_body = objectCopy(options.requestArgs.soapRequest);

    if (options.rawRequestObj) req_body = objectCopy(options.requestArgs.soapRequest[options.rawRequestObj])

    if (!options.soapService || !options.soapBinding || !options.soapOperation) throw Error("Request requestArgs is not defined. Request to remote require requestArgs property option.");

    let req_body_log = req_body == null ? "" :
        JSON.stringify(encryptJsonData(req_body, authenToken, options.encryptFields, options.encryptPinFields, options.bigDataFields, options.removeFields));

    loggerMonitor.info(`2|0|${service_name}|${function_name}||`);
    loggerDebug.debug(`2|0|${service_name}|${function_name}|${req_body_log}|`);

    return new Promise(function (resolve, reject) {

        time_response = moment();
        soap.createClient(options.wsdlEndpoint, options.requestArgs, function (err, client) {

            if (err) {
                execError(err);
                reject(err);
                // execError(new mrtrError({code: err.code, module: service_name}));
            }

            //method client[wsdl:service][wsdl:binding][wsdl:operation]
            var method = client[options.soapService][options.soapBinding][options.soapOperation];

            var requestArgs = options.requestArgs.soapRequest;

            method(requestArgs, function (err, result, envelope, soapHeader) {
                if (err) {
                    execError(err);
                    reject(err);
                }
                let res_body = result ? JSON.stringify(result) : "";
                let elapsedTime = moment().diff(time_response);
                if (client.lastElapsedTime != null) elapsedTime = client.lastElapsedTime;
                let res_body_log = res_body == null ? "" :
                    JSON.stringify(encryptJsonData(res_body, authenToken, options.encryptFields, options.encryptPinFields, options.bigDataFields, options.removeFields));

                loggerMonitor.info(`3|${elapsedTime}|${service_name}|${function_name}||`);
                loggerDebug.debug(`3|${elapsedTime}|${service_name}|${function_name}|${res_body_log}|`);

                resolve(result);
            }, {
                time: true
            });
        }, options.endpoint);
    });
}

const attachLoggerMiddleWare = (req, res, next) => {
    req.functionName = req.url.split('/').pop()
    morganEncryptRequestHeader(null, req, res)
    const logger = {
        functionName: req.functionName,
        authenToken: (req.headers['x-authorization'] || ""),
        encryptJsonData: function (body, encs, pins, bigs, dels) {
            return encryptJsonData(body, logger.authenToken, encs, pins, bigs, dels);
        },
        registerRequestPromiseWithSupportDeflate: registerRequestPromiseWithSupportDeflate,
        registerRequestPromise: registerRequestPromise,
        registerSoapPromise: registerSoapPromise,
        getLegacyMonitorMessage: getLegacyMonitorMessage,
        info: {
            hostname: req.server_name, //Hostname
            UDID: req.headers['udid'], //UDID
            cli_number: req.headers['cli-number'], //Cli-Number
            user_name_login: req.encryptedUserNameLogin, //User-Name-Login
            client_ip: req.headers['x-real-ip'] || req.headers['x-forwarded-for'] || req.headers['cf-connecting-ip'] ||
                req.headers['remote-addr'] || "", //Client-IP
            app_vesion: req.headers['app-version'], //App-Vesion
            client_os: req.headers['client-os'], //Client-OS
            jail_status: req.headers['jail-status'], //Jail-Status
            client_model: req.headers['client-model'], //Client-Model
            network_type: req.headers['network-type'], //Network-Type
            rtr_code: req.headers['rtr-code'], //RTR-Code
            sim_r_number: req.encryptedSimrNumber, //Sim-R-Number
            x_authorization: req.auth_token, //X-Authorization
            transaction_id: (req.headers['x-request-id'] || "").replace(/-/g, '').toUpperCase(), // TransactionID 
            request_url: req.url, //RequestURL
            message_step: "", // MessageStep
            diff_time: "", //DiffTime(ms)
            legacy_name: "", //LegacyName
            legacy_return_code: "", //LegacyReturnCode
            error_type: "", //ErrorType
            error_code: "", //ErrorCode
            lat_long: req.headers['lat-long'], //Lat-Long
            customer_mobile: cryptoUtils.encrypt(req.headers['customer-mobile']), //customer_number
            txn_amount: req.txn_amount, //txn_amount
            base64_size: req.file_size, //base64_size
            x_feature_session_id: (req.headers['x-feature-session-id'] || "").replace(/-/g, '').toUpperCase(), //x_feature_session_id
            x_company: req.headers['x-company'] || "ALL"
        },
        formatting: function (opt) {
            let message_step = null;
            let diff_time = null;
            let service_name = null;
            let return_code = null;
            let error_type = null;
            let error_code = null;

            if(typeof(opt) === "object") {
                message_step = opt.message_step || "1";
                diff_time = opt.diff_time || "0";
                service_name = opt.service_name || "MRTR";
                return_code = opt.return_code || "";
                error_type = opt.error_type || "";
                error_code = opt.error_code || "";
            }
            if(typeof(opt) === "string") {
                if(opt.includes("|")) {
                    const coll = opt.split("|");
                    message_step = coll[0] || "";
                    diff_time = coll[1] || "";
                    service_name = coll[2] || "";
                    return_code = coll[3] || "";
                    error_type = coll[4] || "";
                    error_code = coll[5] || "";
                }
                else {
                    error_type = opt;
                }
            }
            return [
                logger.info.hostname,
                logger.info.UDID,
                logger.info.cli_number,
                logger.info.user_name_login,
                logger.info.client_ip,
                logger.info.app_vesion,
                logger.info.client_os,
                logger.info.jail_status,
                logger.info.client_model,
                logger.info.network_type,
                logger.info.rtr_code,
                logger.info.sim_r_number,
                logger.info.x_authorization,
                logger.info.transaction_id,
                logger.info.request_url,
                message_step || "1",
                diff_time || "0",
                service_name || "MRTR",
                return_code || "",
                error_type || "",
                error_code || "",
                logger.info.lat_long,
                logger.info.customer_mobile,
                logger.info.txn_amount,
                logger.info.base64_size,
                logger.info.x_feature_session_id,
                logger.info.x_company
            ].join("|");
        },
        // loggerMonitor: loggerMonitor,
        // loggerDebug: loggerDebug,
        monitor: {
            info: function (opt) {
                loggerMonitor.info(logger.formatting(opt.replace(/\r\n|\r|\n|\t/g, ' ')));
            },
            log: function (opt) {
                loggerMonitor.log(logger.formatting(opt.replace(/\r\n|\r|\n|\t/g, ' ')));
            },
        },
        debug: {
            log: function (opt) {
                loggerDebug.debug(logger.formatting(opt.replace(/\r\n|\r|\n|\t/g, ' ')));
            },
            debug: function (opt) {
                loggerDebug.debug(logger.formatting(opt.replace(/\r\n|\r|\n|\t/g, ' ')));
            },
            error: function (opt) {
                loggerDebug.error(logger.formatting(opt.replace(/\r\n|\r|\n|\t/g, ' ')));
            }
        },

    };
    res.locals.logger = logger;
    next();
};


const registerExpress = (app) => {
    captureResponseBodyMiddleWare(app);
    app.use(getServerNameMiddleWare);
    app.use(genTransactionIdMiddleWare);
    app.use(getTransactionAmountMiddleWare);

    app.use(attachLoggerMiddleWare);

    app.use(monitorRequest);
    app.use(monitorResponse);

    app.use(debugRequest);
    app.use(debugResponse);

};

const createMrtrLogger = (conf) => {
    configs = conf || configs || {};

    monitorTransporter = monitorTransporter || createTransporter('monitor', logMorganMonitorTransportFormatter);
    legacyMonitorTransporter = legacyMonitorTransporter || createTransporter('monitor', logMorganMonitorTransportFormatter);
    debugTransporter = debugTransporter || createTransporter('debug', logMorganDebugTransportFormatter);
    exceptionTransporter = exceptionTransporter || createTransporter('exception', logMorganDebugTransportFormatter);
    legacyDebugTransporter = legacyDebugTransporter || createTransporter('debug', logLegacyDebugTransportFormatter);
    legacyExceptionTransporter = legacyExceptionTransporter || createTransporter('exception', logLegacyDebugTransportFormatter);
    morganMonitorTransporter = morganMonitorTransporter || createTransporter('monitor', logMorganMonitorTransportFormatter);
    morganDebugTransporter = morganDebugTransporter || createTransporter('debug', logMorganDebugTransportFormatter);
    morganExceptionTransporter = morganExceptionTransporter || createTransporter('exception', logMorganDebugTransportFormatter);

    loggerMorganMonitor = loggerMorganMonitor || new winston.Logger({
        transports: [morganMonitorTransporter].filter(it => it != null),
        exitOnError: false,
        emitErrs: false
    });
    loggerMorganDebug = loggerMorganDebug || new winston.Logger({
        transports: [morganDebugTransporter, morganExceptionTransporter].filter(it => it != null),
        exitOnError: false,
        levels: monitorLogLevels
    });

    loggerMonitor = loggerMonitor || new winston.Logger({
        transports: [monitorTransporter],
        exitOnError: false
    });
    legacyMonitor = legacyMonitor || new winston.Logger({
        transports: [monitorTransporter],
        exitOnError: false
    });
    loggerDebug = loggerDebug || new winston.Logger({
        transports: [debugTransporter, exceptionTransporter].filter(it => it != null),
        exitOnError: false,
        levels: monitorLogLevels
    });

    legacyDebug = legacyDebug || new winston.Logger({
        transports: [legacyDebugTransporter, legacyExceptionTransporter].filter(it => it != null),
        exitOnError: false,
        levels: monitorLogLevels
    });

    loggerMorganMonitor.emitErrs = false;
    loggerMorganDebug.emitErrs = false;

    return {
        monitor: loggerMonitor,
        debug: loggerDebug,
        legacyDebug: legacyDebug,
        registerExpress: registerExpress,
        registerRequestPromiseWithSupportDeflate: registerRequestPromiseWithSupportDeflate,
        registerRequestPromise: registerRequestPromise,
        registerSoapPromise: registerSoapPromise,
        getLegacyMonitorMessage: getLegacyMonitorMessage,
    }
}

module.exports = createMrtrLogger;
module.exports.getLegacyMonitorMessage = getLegacyMonitorMessage;