class CryptoUtils {

    constructor(config) {

        const crypto = require('crypto');
        const env = process.env.NODE_ENV;
        this.SECRET_KEY = "ABCDEFGHIJKLMNOP12345678";
        this.AES_SECRET_KEY = "QD3jnECG3TFl3jOmIhLJMiqX2WAABxKx";
        if (config == null) {
            const appPath = process.cwd();
            const config_obj = require(appPath + '/../conf/application.json')[env];
            if (config_obj.secretKey != null)
                this.SECRET_KEY = config_obj.secretKey;
            if (config_obj.aesKey != null)
                this.AES_SECRET_KEY = config_obj.aesKey;
        } else
        if (typeof config === 'string') {
            const config_obj = require(config)[env];
            if (config_obj.secretKey != null)
                this.SECRET_KEY = config_obj.secretKey;
            if (config_obj.aesKey != null)
                this.AES_SECRET_KEY = config_obj.aesKey;
        } else
        if (typeof config === 'object') {
            if (config.secretKey != null)
                this.SECRET_KEY = config.secretKey;
            if (config.aesKey != null)
                this.AES_SECRET_KEY = config.aesKey;
        }
        this.IV = new Buffer(8);
        this.ENCODING = "base64";
    }

    encrypt(decText) {

        if (decText === null || decText === "" || typeof decText === 'undefined') { return decText }
        const crypto = require('crypto');

        let encText = "";
        const cipher = crypto.createCipheriv('des-ede3-cbc', this.SECRET_KEY, this.IV);
        encText = cipher.update(decText, 'utf8', this.ENCODING);
        encText += cipher.final(this.ENCODING);

        return encText;
    };

    decrypt(encText) {

        if (encText === null || encText === "" || typeof encText === 'undefined') { return encText }
        const crypto = require('crypto');

        let decText = "";
        const decipher = crypto.createDecipheriv('des-ede3-cbc', this.SECRET_KEY, this.IV);
        decText = decipher.update(encText, this.ENCODING, 'utf8');
        decText += decipher.final('utf8');

        return decText;
    };

    encryptPin(textToEncrypt, loginTokenUUID32Char) {

        const crypto = require('crypto');

        let FIRST_CHAR_POSITION_FOR_SECRET_KEY = 0;
        let BEFORE_CHAR_POSITION_FOR_SECRET_KEY = 24;
        let FIRST_CHAR_POSITION_FOR_IV = 24;
        let BEFORE_CHAR_POSITION_FOR_IV = 32;

        let SECRET_KEY_TO_ENCRYPT_PIN = "";
        try { SECRET_KEY_TO_ENCRYPT_PIN = loginTokenUUID32Char.substring(FIRST_CHAR_POSITION_FOR_SECRET_KEY, BEFORE_CHAR_POSITION_FOR_SECRET_KEY); }
        catch(e) { return textToEncrypt; }

        let tokenForIV = "";
        try { tokenForIV = loginTokenUUID32Char.substring(FIRST_CHAR_POSITION_FOR_IV, BEFORE_CHAR_POSITION_FOR_IV); }
        catch(e) { return textToEncrypt; }

        let IV_FOR_PIN = new Buffer.from(tokenForIV);

        const cipher = crypto.createCipheriv('des-ede3-cbc', SECRET_KEY_TO_ENCRYPT_PIN, IV_FOR_PIN);

        let textAfterEncrypt = cipher.update(textToEncrypt, 'utf8', this.ENCODING);
        textAfterEncrypt += cipher.final(this.ENCODING);

        return textAfterEncrypt;
    };

    decryptPin(textToDecrypt, loginTokenUUID32Char) {

        const crypto = require('crypto');

        let FIRST_CHAR_POSITION_FOR_SECRET_KEY = 0;
        let BEFORE_CHAR_POSITION_FOR_SECRET_KEY = 24;
        let FIRST_CHAR_POSITION_FOR_IV = 24;
        let BEFORE_CHAR_POSITION_FOR_IV = 32;

        if(textToDecrypt === null || textToDecrypt === "") { return textToDecrypt; }

        let SECRET_KEY_TO_DECRYPT_PIN = "";
        try { SECRET_KEY_TO_DECRYPT_PIN = loginTokenUUID32Char.substring(FIRST_CHAR_POSITION_FOR_SECRET_KEY, BEFORE_CHAR_POSITION_FOR_SECRET_KEY); }
        catch(e) { return textToDecrypt; }

        let tokenForIV = "";
        try { tokenForIV = loginTokenUUID32Char.substring(FIRST_CHAR_POSITION_FOR_IV, BEFORE_CHAR_POSITION_FOR_IV); }
        catch(e) { return textToDecrypt; }

        let IV_FOR_PIN = new Buffer.from(tokenForIV);

        const decipher = crypto.createDecipheriv('des-ede3-cbc', SECRET_KEY_TO_DECRYPT_PIN, IV_FOR_PIN);

        let textAfterDecrypt = "";
        try {
            textAfterDecrypt = decipher.update(textToDecrypt, this.ENCODING, 'utf8');
            textAfterDecrypt += decipher.final('utf8');
        }
        catch(e) {
            return textToDecrypt;
        }

        return textAfterDecrypt;
    };

    hash(decText) {
        const crypto = require('crypto');
        let hash = crypto.createHash('sha1','').update(decText).digest('hex');
        return hash;
    };

    async getKeyAES(configKey = 'dataPrivacy.encryption.aes256cbc.key'){

        const db = require('../../models_readonly');

        let mrtrTransKey = await db.MrtrConfig.findOne({ where: {key: configKey, status:'ACTIVE'} }).then( result => { return (result !== null) ? result.dataValues : null; } );
        if(mrtrTransKey === null )return this.AES_SECRET_KEY 
        return mrtrTransKey.value
    }

    encryptAES(text , key) {

        if (text === null || text === "" || typeof text === 'undefined') { return text }

        const crypto = require('crypto');

        let iv = crypto.randomBytes(16);
        let keyBuffer = Buffer.from(key.toString(), 'utf8')
        let cipher = crypto.createCipheriv('aes-256-cbc', keyBuffer, iv);
        let encrypted = cipher.update(text);
        let encryptedText = Buffer.concat([iv, encrypted, cipher.final()]).toString('hex')
        return encryptedText

    }

    decryptAES(text , key) {

        if (text === null || text === "" || typeof text === 'undefined') { return text }

        const crypto = require('crypto');

        let message = Buffer.from(text, 'hex').slice(16);
        let ivBuffer = Buffer.from(text, 'hex').slice(0, 16)
        let keyBuffer = Buffer.from(key.toString(), 'utf8')
        let decipher = crypto.createDecipheriv('aes-256-cbc', keyBuffer, ivBuffer);
        let decrypted = decipher.update(message, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    }

    //AES256_IV_PG
    encryptAES256IV (text, key, salt) {
        let crypto = require('crypto');
        let iv = Buffer.from(salt.substr(0, 16), 'ascii');
        let cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
        let encrypted = cipher.update(text, 'utf8', 'base64');
        encrypted += cipher.final('base64');
        return encrypted;
    }
    decryptAES256IV (encData, key, salt) {
        let crypto = require('crypto');
        let iv = Buffer.from(salt.substr(0, 16), 'ascii');
        let decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
        let decrypted = decipher.update(encData, 'base64', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    }
    
}

module.exports = CryptoUtils;

